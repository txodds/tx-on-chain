{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TxODDS Oracle Examples","text":"<p>This repository showcases usage of the Tx Oracle on-chain contract, demonstrating how to interact with sports data validation using Solana blockchain technology.</p>"},{"location":"#overview","title":"Overview","text":"<p>Tx Oracle is a hybrid Solana on-chain and TxODDS hosted off-chain system. It supports the following two main use key cases:</p> <ol> <li>Data Access Layer. Make proprietary TxODDS data available for any funded blockchain users by linking the on-chain subscribe transactions with issued time-limited API tokens.</li> <li>The data is canonicalised so that all fixtures, odds, or scores are provably unique and can be validated on-chain using cryptographic proofs based on Merkle roots for batches of respective data published to the Solana blockchain.</li> <li>The data is delivered in a request-response or streaming form.</li> <li> <p>One-week long subscriptions are established using a cryptographically secure protocol that assumes that a funded Solana user wallet can (programmatically) purchase <code>TxODDS subscription tokens</code> and pay (at the time of writing) a fixed amount of tokens for one-week long access to proprietary data.</p> </li> <li> <p>Prediction-based trading Sophisticated and highly general binary options Trading that allows users to:</p> </li> <li>submit cryptographically signed College Football and Basketball prediction offers for specified time periods,</li> <li>receive via stream the resulting notifications to paid subscribers over the Trading stream,</li> <li>accept and cryptorgaphically sign the offers (once the trade match is confirmed by the off-chain service, a fully-secure on-chain escrow is created with the matching sides token funds),</li> <li>settle the trades if they have identified a scores record that proves the trade can be resolved in their favour, with escrow funds released into the winner's account.</li> </ol> <p>The following is a basic diagram showing the system in operation.</p> <p></p> <p>The OpenAPI documentation is available at    - https://oracle-dev.txodds.com/docs for Solana DevNet use.    - https://oracle.txodds.com/docs for Solana MainNet use.</p> <p>The data the Oracle system is currently offering includes - fixture snapshots/updates: every time any key metadata for a fixture changes, an update becomes available; - odds: specifically, what is known as TxODDS stable de-margined price available for much more sports and markets in the TxODDS Fusion product; - scores: fully detailed (down to every on-the field action) updates for US College Football and US College Basketball matches.</p> <p>The data is distributed in real-time via request-response or low latency streaming to paying blockchain customers known only by the public keys of their wallets. Simultaneously, the batches accumulated over revolving UTC clock-aligned time intervals periods of 5 minutes for odds and scores and 1 jour for fixture snapshots, are cryptographically signed at the end of these intervals. The resulting signature, known as a <code>Merkle root</code>, is published on-chain in perpetuity. The <code>txoracle</code> Solana program developed by TxODDS in the Rust language and deployed to both Solana DevNet and Solana MainNet (see the public keys below) is working in tandem with the off-chain components to ensure that any published data from the above three channels can be validated against the on-chain signatures.</p> <p>This validation is based on the mathematical property of Merkle roots such that it is possoble to cryptographically verify whether a given record is contained in the referenced batch of data. This serves two purposes: first, the customers can ascertain that the fixture, odds, or scores event was genuine, and secondly, they can engage is trading activities facilitated by the on-chain <code>txoracle</code> program and the TxODDS off-chain services, such that one side is able to propose a signed offer based on a prediction that a certain scores event will occur at the specific phase of the game and once the counter-party \"agrees to disagreee\", accepting the challenge, and with the signed Trade published on-chain, the settlement and funds allocation is based on on-chain proofs that the winning condition was verified. A non-custodial orderbook trading model is also in preparation.</p> <p>Essentialy the data access layer (use case 1) allows users to front-run their trading activity (use case 2), being fully informed about actual fixture changes, odds, and score events in near real-time--with settlement available as soon as the data is fully confirmed by the published on-chain batch signatures--typically as soon as the current 5-minute interval ends and the corresponding phase of the game arrives, or at the end of the previous completed game phase if the prediction period corresponds to the 'completion phase' (such as Q3 break or break before overtime 2) of the previous active phase.</p>"},{"location":"#included-data","title":"Included data","text":"<p>As of mid-September 2025, the following data is covered for the fixtures, odds, and scores channels, and available for trading.</p> Competition ID League Name 550001 NCAA Division I FCS 10005930 NCAA Extra Matches 500005 NCAA Division I FBS 10005302 NCAA Division I (W) 300043 NCAA Division I <p>With the upcoming US basketball season, it is expected that data will be available for the the US basketball leagues excluding NBA.</p> <p>The <code>scores</code> channel includes the fully detailed model of US football (and upcoming baketball) as avaiable otherwide using direct institutional sales offered to big betting operators and syndicats. The documentation for this feed is vailable at the above API endpoints and also in the included document:</p> <p>TxODDS US Football Feed v1.13</p> <p>TxODDS US Baskeball Feed v1.12</p>"},{"location":"#configurations","title":"Configurations","text":""},{"location":"#solana-devnet-contains-matches-re-runs-to-be-used-for-integration","title":"Solana DevNet - contains matches' re-runs to be used for integration","text":"<pre><code>Tx API: https://oracle-dev.txodds.com/api/\nProgram ID: 6pW64gN1s2uqjHkn1unFeEjAwJkPGHoppGvS715wyP2J\nToken Mint: GYdhNurtx2EgiTPRHVGuFWKHPycdpUqgedVkwEVUWVTC\n</code></pre>"},{"location":"#solana-mainnet-contains-actual-live-matches-with-low-latency-delivery-from-off-chain-services-for-example-52-matches-covered-on-sat-20-september-2025","title":"Solana MainNet - contains actual live matches with low-latency delivery from off-chain services (for example, 52 matches covered on Sat, 20 September, 2025)","text":"<pre><code>Tx API: https://oracle.txodds.com/api/\nProgram ID: 9ExbZjAapQww1vfcisDmrngPinHTEfpjYRWMunJgcKaA\nToken Mint: sLX1i9dfmsuyFBmJTWuGjjRmG4VPWYK6dRRKSM4BCSx\n</code></pre>"},{"location":"#access-flow","title":"Access Flow","text":"<p>The following diagram shows how the users typically access data from purchasing the subscription tokens to issuing off-chain calls.</p> <p></p>"},{"location":"#1-purchase-tokens","title":"1. Purchase Tokens","text":"<p>Before accessing the oracle services, you must purchase TxOracle tokens. See <code>purchase_tokens.ts</code> for the complete implementation of token purchasing.</p>"},{"location":"#2-access-off-chain-api","title":"2. Access Off-Chain API","text":"<p>With staked tokens, you can access the off-chain API services through the following request flow:</p> <ol> <li>Guest Authentication - Make a <code>POST /auth/guest/start</code> request to receive a JWT token</li> <li>Create Subscription - Execute an on-chain <code>subscribe_with_token</code> transaction with encrypted JWT payload, which will transfer the price of the subscription in Tx tokens to the TxODDS token treasury.</li> <li>Token Activation - Make a <code>GET /api/token/activate</code> request with the transaction signature and encryption parameters to receive your API access token</li> <li>API Access - Use the API token in subsequent requests to all off-chain services</li> </ol>"},{"location":"#running-the-examples","title":"Running the Examples","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js and npm installed</li> <li>TypeScript and ts-node installed globally or in your project</li> <li>A Solana wallet keypair file</li> <li>SOL for transaction fees (devnet or mainnet depending on configuration)</li> </ul>"},{"location":"#setup","title":"Setup","text":"<ol> <li> <p>Install Dependencies <code>bash    npm install</code></p> </li> <li> <p>Configure Settings    Edit <code>./config.ts</code> to set up your environment:    ```typescript    // Set to true for devnet, false for mainnet    export const IS_DEVNET = true;</p> </li> </ol> <p>// Path to your Solana wallet keypair file    export const KEYPAIR_PATH = './path/to/your/keypair.json';    ```</p>"},{"location":"#running-examples","title":"Running Examples","text":"<p>All example scripts are located in the <code>./examples/</code> directory and can be executed using ts-node:</p> <pre><code># Purchase tokens\nnpx ts-node ./examples/tokens/purchase_tokens.ts\n\n# Stake tokens\nnpx ts-node ./examples/tokens/stake.ts\n\n# Run an example script.\n# Note: Some examples contain Id's that can be modified within the file\nnpx ts-node ./examples/streaming/stream_odds.ts\nnpx ts-node ./examples/snapshots/get_odds_snapshot.ts\nnpx ts-node ./examples/validation/validate_odd_onchain.ts\n\n# Unstake tokens\nnpx ts-node ./examples/tokens/unstake.ts\n</code></pre>"},{"location":"#available-examples","title":"Available Examples","text":""},{"location":"#token-management","title":"Token Management","text":""},{"location":"#examplestokenspurchase_tokensts","title":"<code>examples/tokens/purchase_tokens.ts</code>","text":"<p>Demonstrates how to purchase TxOracle subscription tokens using SOL. 1. Executes on-chain token purchase transaction 2. Transfers tokens from treasury to user's account</p>"},{"location":"#data-snapshots","title":"Data Snapshots","text":""},{"location":"#examplessnapshotsget_fixtures_snapshotts","title":"<code>examples/snapshots/get_fixtures_snapshot.ts</code>","text":"<p>Accesses fixture data via the API. 1. Authenticates and creates API subscription 2. Retrieves fixtures snapshots for a given date/competitionId 4. Shows responses from each snapshot endpoint</p>"},{"location":"#examplessnapshotsget_odds_snapshotts","title":"<code>examples/snapshots/get_odds_snapshot.ts</code>","text":"<p>Accesses odds data via the API. 1. Authenticates and creates API subscription 2. Retrieves odds snapshots for a given fixtureId/date/competitionId 4. Shows responses from each snapshot endpoint</p>"},{"location":"#examplessnapshotsget_scores_snapshotts","title":"<code>examples/snapshots/get_scores_snapshot.ts</code>","text":"<p>Accesses scores data via the API. 1. Authenticates and creates API subscription 2. Retrieves scores snapshots for a given fixtureId/date/competitionId 4. Shows responses from each snapshot endpoint</p>"},{"location":"#data-streaming","title":"Data Streaming","text":""},{"location":"#examplesstreamingstream_oddsts","title":"<code>examples/streaming/stream_odds.ts</code>","text":"<p>Demonstrates real-time odds streaming using Server-Sent Events (SSE). 1. Authenticates and creates API subscription 2. Establishes SSE connection to odds stream 3. Displays live odds messages</p>"},{"location":"#examplesstreamingstream_scorests","title":"<code>examples/streaming/stream_scores.ts</code>","text":"<p>Demonstrates real-time scores streaming using Server-Sent Events (SSE). 1. Authenticates and creates API subscription 2. Establishes SSE connection to scores stream 3. Displays live scores messages</p>"},{"location":"#on-chain-validation","title":"On-Chain Validation","text":""},{"location":"#examplesvalidationvalidate_fixtures_onchaints","title":"<code>examples/validation/validate_fixtures_onchain.ts</code>","text":"<p>Validates fixture data using on-chain cryptographic proofs. 1. Authenticates and creates API subscription 2. Fetches college football fixture data from last Saturday 3. Retrieves validation proofs from the API 4. Constructs proof for On-Chain protocol 5. Executes on-chain validation against ten daily batch roots account 6. Cryptographically proves the fixture</p>"},{"location":"#examplesvalidationvalidate_odds_onchaints","title":"<code>examples/validation/validate_odds_onchain.ts</code>","text":"<p>Validates odds data using on-chain cryptographic proofs. 1. Authenticates and creates API subscription 2. Fetches college football fixture data from last Saturday 3. Retrieves odds validation proofs from the API 4. Constructs proof for On-Chain protocol 5. Executes on-chain validation against daily batch roots account 6. Cryptographically proves the price</p>"},{"location":"#examplesvalidationvalidate_scores_onchaints","title":"<code>examples/validation/validate_scores_onchain.ts</code>","text":"<p>Validates scores data using on-chain cryptographic proofs. 1. Authenticates and creates API subscription 2. Fetches college football fixture data from last Saturday 3. Retrieves stat validation proofs from the API 4. Constructs proof for On-Chain protocol 5. Executes on-chain validation against daily scores roots account 6. Cryptographically proves the stat</p>"},{"location":"#trading-flow","title":"Trading Flow","text":"<p>The following diagram gives an overview of how binary options predication markets work with TxODDS Oracle.</p> <p></p> <p>Trading is based on predictions of what one or two stats will be in a given phase of the game (currently covering US Football).</p> <p>Importantly, there are two time periods involved:</p> <ol> <li>Game phase: the phase of the game where an event that matches the prediction will happen.</li> <li>Stat period: the phase of the game for which the respective stats are computed.</li> </ol> <p>A prediction will be confirmed IF AND ONLY IF there exists a record with confirmed stats within the given game phase that meets the prediction condition. For the prediction to be settled and funds dispersed according to the result, the winner side sibmits a proof of such record matching the trade details in their favour that can be validated on-chain to have existed within this phase of the game.</p> <p>This is an example to help with understanding these two time periods.</p>"},{"location":"#example","title":"Example","text":"<p>Prediction might concern the margin of difference between the counts of touchdowns in Q2 of the game. In this case, Q2 is the stat period. The question is when it is predicted this margin will have occurred. The game phase could be set to end of Q2, that is what is known in the TxODDS scores product as Q2B--the break in the game after Quarter 2.</p> <p>Another prediction could be set to be based on a stat that is related to the first half of the game, so the stat period could be easily adjust to become H1 and then the nature of the prediction changes accordingly.</p> <p>There is a further important question: what is the difference between a prediction for the game phase Q2 and Q2B? The latter is very easy to understand: if the prediction concerns a record with confirmed game stats for Q2B, the stats will correspond to the Q2 result--because once the game is in a break, the stats correspond to the result of the previous active phase of the game, which is, in the example, Q2. What happens if the game phase is set to Q2 itself? The prediction logic outlined above dictates that there must exist at least a single record within the whole Q2 that matches the prediction condition. This latter type of predictions could be fully settled as soon as the current 5-minute interval expires (as long as the qualifying event had occurred before its end) supporting very fast turnaround of bets and settlements.</p>"},{"location":"#game-phase-encoding","title":"Game phase encoding","text":"<p>For US football, the game phases are encoded in a unique and economical way for easy prediction proofs on-chain. There are core </p> Name ID Game phase Description <code>NS</code> 1 Not started Status before the game is started <code>Q1</code> 2 Quarter 1 Game in play during first quarter <code>Q1B</code> 3 Quarter 1 break Pause in play between the 1st quarter ending and the 2nd quarter starting <code>Q2</code> 4 Quarter 2 Game in play during second quarter <code>HT</code> 5 Halftime Halftime of the game <code>Q3</code> 6 Quarter 3 Game in play during third quarter <code>Q3B</code> 7 Quarter 3 break Pause in play between the 3rd quarter ending and the 4th quarter starting <code>Q4</code> 8 Quarter 4 Game in play during fourth quarter <code>F</code> 9 Ended (finished) Game ends after the 4th quarter <code>WO</code> 10 Waiting for Overtime Break following the 4th Quarter before the start of the first overtime period <code>OT</code> 11 Overtime With option for overtime number to be selected. Game in play during selected overtime period <code>OB</code> 12 Overtime Break Break between Overtime periods <code>FO</code> 13 Ended after Overtime (Finished after Overtime) Game ends after an overtime period <code>I</code> 14 Interrupted The game is officially interrupted <code>A</code> 15 Abandoned The game is officially abandoned <code>C</code> 16 Cancelled The game is officially cancelled <code>TXCC</code> 17 TX Coverage Cancelled TxODDS cancelled coverage of the event <code>TXCS</code> 18 TX Coverage Suspended TxOODS suspended coverage of the event"},{"location":"#overtime-status-these-are-specific-to-the-txodds-oracle-system","title":"Overtime status -- these are specific to the TxODDS Oracle system","text":"Name ID Game phase <code>OT1</code> 1011 Overtime 1 <code>OB1</code> 1012 Overtime 1 break <code>OT2</code> 2011 Overtime 2 <code>OB2</code> 2012 Overtime 2 break <code>OT3</code> 3011 Overtime 3 <code>OB3</code> 3012 Overtime 3 break <code>OT4</code> 4011 Overtime 4 <code>OB4</code> 4012 Overtime 4 break <code>OT5</code> 5011 Overtime 5 <code>OB5</code> 5012 Overtime 5 break <code>OT6</code> 6011 Overtime 6 <code>OB6</code> 6012 Overtime 6 break <code>OT7</code> 7011 Overtime 7 <code>OB7</code> 7012 Overtime 7 break <code>OT8</code> 8011 Overtime 8 <code>OB8</code> 8012 Overtime 8 break <code>OT9</code> 9011 Overtime 9 <code>OB9</code> 9012 Overtime 9 break <code>OT10</code> 10011 Overtime 10 <code>OB10</code> 10012 Overtime 10 break <code>OT11</code> 11011 Overtime 11 <code>OB11</code> 11012 Overtime 11 break <code>OT12</code> 12011 Overtime 12 <p>Prediction offers reference the game phase by ID taken from the above two tables.</p>"},{"location":"#stat-period-encoding","title":"Stat period encoding","text":"<p>The stat period is also encoded economically as follows:</p>"},{"location":"#full-game-stats","title":"Full Game Stats","text":"Key Statistic Description 1 Participant 1 Total Score 2 Participant 2 Total Score 3 Participant 1 Total Touchdowns 4 Participant 2 Total Touchdowns 5 Participant 1 Total Field Goals 6 Participant 2 Total Field Goals 7 Participant 1 Total 1pt Conversions 8 Participant 2 Total 1pt Conversions 9 Participant 1 Total 2pt Conversions 10 Participant 2 Total 2pt Conversions 11 Participant 1 Total Safeties 12 Participant 2 Total Safeties 13 Participant 1 Total 1pt Safeties 14 Participant 2 Total 1pt Safeties 15 Participant 1 Total Defensive 2pt Conversions 16 Participant 2 Total Defensive 2pt Conversions"},{"location":"#first-half-ht-stats","title":"First Half (HT) Stats","text":"Key Statistic Description 1001 Participant 1 1st Half Score 1002 Participant 2 1st Half Score 1003 Participant 1 1st Half Touchdowns 1004 Participant 2 1st Half Touchdowns 1005 Participant 1 1st Half Field Goals 1006 Participant 2 1st Half Field Goals 1007 Participant 1 1st Half 1pt Conversions 1008 Participant 2 1st Half 1pt Conversions 1009 Participant 1 1st Half 2pt Conversions 1010 Participant 2 1st Half 2pt Conversions 1011 Participant 1 1st Half Safeties 1012 Participant 2 1st Half Safeties 1013 Participant 1 1st Half 1pt Safeties 1014 Participant 2 1st Half 1pt Safeties 1015 Participant 1 1st Half Defensive 2pt Conversions 1016 Participant 2 1st Half Defensive 2pt Conversions"},{"location":"#second-half-q3q4-stats","title":"Second Half (Q3+Q4) Stats","text":"Key Statistic Description 2001 Participant 1 2nd Half Score 2002 Participant 2 2nd Half Score 2003 Participant 1 2nd Half Touchdowns 2004 Participant 2 2nd Half Touchdowns 2005 Participant 1 2nd Half Field Goals 2006 Participant 2 2nd Half Field Goals 2007 Participant 1 2nd Half 1pt Conversions 2008 Participant 2 2nd Half 1pt Conversions 2009 Participant 1 2nd Half 2pt Conversions 2010 Participant 2 2nd Half 2pt Conversions 2011 Participant 1 2nd Half Safeties 2012 Participant 2 2nd Half Safeties 2013 Participant 1 2nd Half 1pt Safeties 2014 Participant 2 2nd Half 1pt Safeties 2015 Participant 1 2nd Half Defensive 2pt Conversions 2016 Participant 2 2nd Half Defensive 2pt Conversions"},{"location":"#quarter-1-stats","title":"Quarter 1 Stats","text":"Key Statistic Description 10001 Participant 1 Q1 Score 10002 Participant 2 Q1 Score 10003 Participant 1 Q1 Touchdowns 10004 Participant 2 Q1 Touchdowns 10005 Participant 1 Q1 Field Goals 10006 Participant 2 Q1 Field Goals 10007 Participant 1 Q1 1pt Conversions 10008 Participant 2 Q1 1pt Conversions 10009 Participant 1 Q1 2pt Conversions 10010 Participant 2 Q1 2pt Conversions 10011 Participant 1 Q1 Safeties 10012 Participant 2 Q1 Safeties 10013 Participant 1 Q1 1pt Safeties 10014 Participant 2 Q1 1pt Safeties 10015 Participant 1 Q1 Defensive 2pt Conversions 10016 Participant 2 Q1 Defensive 2pt Conversions"},{"location":"#quarter-2-stats","title":"Quarter 2 Stats","text":"Key Statistic Description 20001 Participant 1 Q2 Score 20002 Participant 2 Q2 Score 20003 Participant 1 Q2 Touchdowns 20004 Participant 2 Q2 Touchdowns 20005 Participant 1 Q2 Field Goals 20006 Participant 2 Q2 Field Goals 20007 Participant 1 Q2 1pt Conversions 20008 Participant 2 Q2 1pt Conversions 20009 Participant 1 Q2 2pt Conversions 20010 Participant 2 Q2 2pt Conversions 20011 Participant 1 Q2 Safeties 20012 Participant 2 Q2 Safeties 20013 Participant 1 Q2 1pt Safeties 20014 Participant 2 Q2 1pt Safeties 20015 Participant 1 Q2 Defensive 2pt Conversions 20016 Participant 2 Q2 Defensive 2pt Conversions"},{"location":"#quarter-3-stats","title":"Quarter 3 Stats","text":"Key Statistic Description 30001 Participant 1 Q3 Score 30002 Participant 2 Q3 Score 30003 Participant 1 Q3 Touchdowns 30004 Participant 2 Q3 Touchdowns 30005 Participant 1 Q3 Field Goals 30006 Participant 2 Q3 Field Goals 30007 Participant 1 Q3 1pt Conversions 30008 Participant 2 Q3 1pt Conversions 30009 Participant 1 Q3 2pt Conversions 30010 Participant 2 Q3 2pt Conversions 30011 Participant 1 Q3 Safeties 30012 Participant 2 Q3 Safeties 30013 Participant 1 Q3 1pt Safeties 30014 Participant 2 Q3 1pt Safeties 30015 Participant 1 Q3 Defensive 2pt Conversions 30016 Participant 2 Q3 Defensive 2pt Conversions"},{"location":"#quarter-4-stats","title":"Quarter 4 Stats","text":"Key Statistic Description 40001 Participant 1 Q4 Score 40002 Participant 2 Q4 Score 40003 Participant 1 Q4 Touchdowns 40004 Participant 2 Q4 Touchdowns 40005 Participant 1 Q4 Field Goals 40006 Participant 2 Q4 Field Goals 40007 Participant 1 Q4 1pt Conversions 40008 Participant 2 Q4 1pt Conversions 40009 Participant 1 Q4 2pt Conversions 40010 Participant 2 Q4 2pt Conversions 40011 Participant 1 Q4 Safeties 40012 Participant 2 Q4 Safeties 40013 Participant 1 Q4 1pt Safeties 40014 Participant 2 Q4 1pt Safeties 40015 Participant 1 Q4 Defensive 2pt Conversions 40016 Participant 2 Q4 Defensive 2pt Conversions <p>There is a very simple formula used for the above encoding such that the half number is multiplied by 1000 while the quarter number is multiplied by 10000. It is then added to the original code for the full game.</p>"},{"location":"#specify-the-stat-period","title":"Specify the stat period","text":"<p>The Stat period as used in offers and settlements is wrapped in the <code>StatTerm</code> class that designates the statistic used for prediction. For example:</p> <pre><code>{ key: 1 } // Stat key for \"Participant1_Score\"\n</code></pre>"},{"location":"#specify-a-trading-predicate","title":"Specify a trading predicate","text":"<p>A trading predicate is wrapped in the <code>Predicate</code> class with a nested <code>ComparisonEnum</code>. Here is an example in TypeScript:</p> <pre><code>const predicate = {\n  threshold: 11,\n  comparison: { greaterThan: {} }, \n};    \n</code></pre> <p>Essentially, the trading predicate sets a bar to compare against and accepts three modes for comparison: <code>greaterThan</code>, <code>lessThan</code>, and <code>equalTo</code>. Predicates do not specify what expression  or statistics to use, instead, they just capture the actual comparison being made against the specified quantity (threshold).</p>"},{"location":"#specify-an-optional-binary-expression","title":"Specify an optional binary expression","text":"<p>A binary expression (when not-null) is either <code>add</code> or <code>subtract</code> is wrapped in the <code>BinaryOpEnum</code> class. For example,</p> <p>binaryOp = {    add: {} }</p>"},{"location":"#create-a-new-offer","title":"Create a new offer","text":"<p>An <code>Offer</code> structure wraps all necessary information for specifying the prediction and associated terms made by the offer originator side (trader). Here is an example of a one-stat prediction:</p> <pre><code>const predicate = {\n  threshold: 11,\n  comparison: { greaterThan: {} }, \n};    \n\nconst offer = new schema.Offer({\n   fixtureId: new BN(17271370),\n   period: 4, // Q2\n   predicate,\n   binaryOp: null, // This is a single-stat predicate\n   statA: { key: 1 }, // Stat key for \"Participant1_Score\"\n   statB: null,\n   stake: new BN(500_000_000), // 0.5 SOL\n   odds: 2000, // 2.0 decimal odds\n   expiration: new BN(Date.now() + 60 * 60 * 1000), // Expires in 1 hour\n   traderPubkey: user.publicKey,\n});\n</code></pre> <p>The <code>odds</code> are decimal odds, multiplied by 1000 to preserve a three-decimal point precision. The decimal odds mean that if the prediction turns out to be true, trader A stands to double their original stake--with the eventual counter-party losing the amount of tokens equivalent to 0.5 SOL. The offer states that the specified fixture during the half-time break is going to have the team A's total score greater than 11--this being the result after the two quarters are fully played. The offer will be self-managed so that after an hour from the offer submission, the matching by counter-parties will be disabled.</p> <p>Once the offer is acknoledged by the TxODDS off-chain service, the subscribers to the <code>/trading/stream</code> will receive a nottification <code>NewOffer</code> that looks like this:</p> <pre><code>{ offerId: 6,\n  offer:\n   {\n      fixtureId: 17271370,\n      period: 4,\n      predicate: { threshold: 11, comparison: { type: 'GreaterThan' } },\n      binaryOp: null,\n      statA: { key: 2 },\n      statB: null,\n      stake: 500000000,\n      odds: 2000,\n      expiration: 1758365295729,\n      traderPubkey: '8g2nck8iiaZNjaXA9doPRabA9k1CBKqThPcADfhvC1tF'\n      }\n}\n</code></pre>"},{"location":"#accept-a-new-offer","title":"Accept a new offer","text":"<p>A counter-party trader B may elect to accept this offer, which means that they are confident that the odds of 2.0 that trader A specified are too low, meaning trader B believes the prediction in the offer is unlikely to succeed at these odds. This is how trader B accepts the offer:</p> <pre><code>const messageBuffer = new BN(offerIdToAccept).toBuffer('le', 4);\nconst signature = nacl.sign.detached(messageBuffer, user.secretKey);\n\nconst acceptancePayload = {\n   offerId: offerIdToAccept,\n   acceptingTraderPubkey: user.publicKey.toBase58(),\n   signature: bs58.encode(signature),\n};\n\nconst response = await axios.post(`${API_BASE_URL}/api/trading/accept`, acceptancePayload, {\n   headers: {\n      'Authorization': `Bearer ${jwt}`,\n      'X-Api-Token': apiToken\n   }\n});\n</code></pre> <p>Once the TxODDS of-chain service receives a counter-offer on the <code>accept</code> endpoint, it creates a new unsigned Solana transaction <code>create_trade</code> and sends it to both trades for signing via this <code>SigningRequest</code> message:</p> <pre><code>{\n   tradeId: 6,\n   partiallySignedTx: 'abc',\n   recipientPubkey: 'abc'\n}\n</code></pre>"},{"location":"#both-parties-sign-the-trade","title":"Both parties sign the trade","text":"<p>For the <code>create_trade</code> to be executable on blockchain, it needs to have three signers: both traders and the authority behind the <code>txoracle</code> program belonging to TxODDS. The latter is obviously readily available to our off-chain service but the former two signatures need to be explicitly collected from traders. The above <code>SigningRequest</code> is received by both traders and each use a similar method to sign and send it back to the TxODDS service.</p> <pre><code>const messageToSign = Buffer.from(data.partiallySignedTx, 'base64');\nconst signature = nacl.sign.detached(messageToSign, user.secretKey);\n\nconst signaturePayload = {\n   tradeId: data.tradeId,\n   signer: user.publicKey.toBase58(),\n   signature: bs58.encode(signature),\n};\n\nawait axios.post(`${API_BASE_URL}/api/trading/sign`, signaturePayload, {\n   headers: {\n   'Authorization': `Bearer ${jwt}`,\n   'X-Api-Token': apiToken\n   }\n});\n</code></pre> <p>Once the TxODDS off-chain service receives both signatures, it signs the unsigned transaction with those signatures, adds the TxODDS authority signature and submits the trade to the Solana blockchain using a fully signed <code>create_trade</code> transaction.</p> <p>The TxODDS service then copies the same <code>TradeMatched</code> notifications to respective trading streams for both traders.</p> <pre><code>{\n   offer: {\n   fixtureId: 17271370,\n   period: 4,\n   predicate: { threshold: 11, comparison: { type: 'GreaterThan' } },\n   binaryOp: null,\n   statA: { key: 1 },\n   statB: null,\n   stake: 500000000,\n   odds: 2000,\n   expiration: 1758366631894,\n   traderPubkey: '8g2nck8iiaZNjaXA9doPRabA9k1CBKqThPcADfhvC1tF'\n   }\n}\n</code></pre>"},{"location":"#the-winning-trader-submits-a-settle_trade-transaction-directly-to-the-txoracle-program-on-blockchain","title":"The winning trader submits a <code>settle_trade</code> transaction directly to the <code>txoracle</code> program on blockchain","text":"<p>Both traders manage their positions by front-running their subscriptions to the odds and scores channels. Once one of them is clear the predication can be resolved in their favour (there can be only one winner to any given predicate), they call the off-chain TxODDS service to obtain a partial proof of the scores record that settles the prediction in their favour and then call the <code>txoracle</code> program with this proof.</p> <pre><code>const url = `${API_BASE_URL}/api/scores/stat-validation?fixtureId=17271370&amp;seq=401&amp;statKey=1`\nconst response = await axios.get(url, {\n   headers: {\n      'Authorization': `Bearer ${jwt}`,\n      'X-Api-Token': apiToken\n   }\n});\n</code></pre> <p>The <code>seq</code> uniquely identified the scores update from the scores feed for the fixture in the original offer. The putative winner can locally check that the scores event they consumed will be resolved in their favour. In our worked example, trader B is the winner bacause the actual team A score was not &gt; than 11. Here is the call to on-chain to settle the trade.</p> <pre><code>const [dailyScoresPda, _] = anchor.web3.PublicKey.findProgramAddressSync(\n   [\n      Buffer.from(\"daily_scores_roots\"),\n      new BN(epochDay).toBuffer(\"le\", 2), // epochDay is u16, so 2 bytes little-endian\n   ],\n   program.programId\n);\n\nconst [tradeEscrowPda] = PublicKey.findProgramAddressSync(\n   [\n      Buffer.from(\"escrow\"), \n      tradeId.toBuffer(\"le\", 8)\n   ],\n   program.programId\n);\n\nconst [escrowVaultPda] = PublicKey.findProgramAddressSync(\n   [\n      Buffer.from(\"escrow_vault\"), \n      tradeId.toBuffer(\"le\", 8)\n   ],\n   program.programId\n);\n\nconst txSignature = await program.methods\n   .settleTrade(\n      tradeId,\n      new BN(validation.ts),\n      fixtureSummary,\n      fixtureProof,\n      mainTreeProof,\n      predicate,\n      stat1,\n      null, // stat2\n      null // op\n   )\n   .accounts({\n      winner: user.publicKey,\n      dailyScoresMerkleRoots: dailyScoresPda,\n      tradeEscrow: tradeEscrowPda,\n      escrowVault: escrowVaultPda,\n      winnerTokenAccount: tokenAccount.address,\n      tokenProgram: TOKEN_PROGRAM_ID,\n   })\n   .preInstructions([\n      ComputeBudgetProgram.setComputeUnitLimit({\n      units: 600_000, // max: 1.4M\n      }),\n   ])\n   .signers([user])\n   .rpc();\n</code></pre> <p>The outcome of a successfully settled trade is that the funds are released from the escrow account and transferred to trader B's token account and then the escrow is fully closed. Here is an example of such settlement on DevNet:</p> <p>https://explorer.solana.com/tx/f7t9VqWyumtqAeFuFqRhp8t6QX693h68ZZ5Wa4pe1ebbEusuuRyLDgo4ARpQ4GS8P1CkW6xvstBtQi4z8cyfSup?cluster=devnet</p>"},{"location":"#additional-documentation","title":"Additional Documentation","text":"<p>For comprehensive API documentation:</p> <ul> <li>Mainnet Documentation: oracle.txodds.com/docs</li> <li>Devnet Documentation: oracle-dev.txodds.com/docs</li> </ul>"}]}